% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/densityBasedCellFeatures.R
\name{feature_densityBased_all}
\alias{feature_densityBased_all}
\alias{feature_densityBased_thetaDiff}
\alias{feature_densityBased_translationDiff}
\alias{feature_densityBased_clusterSize}
\alias{densityBasedClusters}
\alias{estimatedRotation}
\title{Calculate features using density-based clustering algorithms}
\usage{
feature_densityBased_all(
  comparisonData_cellBased,
  eps,
  minPts,
  method = "dbscan",
  id_cols = NULL
)

feature_densityBased_thetaDiff(estimatedThetas, direction, imputeVal = NA)

feature_densityBased_translationDiff(x, y, cluster, direction, imputeVal = NA)

feature_densityBased_clusterSize(cluster, direction, imputeVal = NA)

densityBasedClusters(x, y, eps, minPts, method = "dbscan")

estimatedRotation(x, y, theta)
}
\arguments{
\item{comparisonData_cellBased}{tibble such as one returned by the
\code{comparison_cellBased()} function that contains results from the cell-based
comparison procedure}

\item{eps}{a double representing the neighborhood radius used in the DBSCAN
algorithm}

\item{minPts}{an integer representing the minimum neighborhood size used in
the DBSCAN algorithm}

\item{method}{a character vector that specifies the algorithm used to find
clusters. Must be either "dbscan" or "hdbscan" or "optics" - see the dbscan
package for more information.}

\item{id_cols}{column names in the comparisonData tibble that uniquely
identify each observation. These are returned along with the computed
features}

\item{direction}{tibble column containing characters "reference_vs_target" or
"target_vs_reference" that specify the comparison direction associated with
the observation}

\item{imputeVal}{value to return if the feature calculation results in a
non-numeric (i.e., NA, NULL) value}

\item{x}{tibble column containing estimated horizontal translations}

\item{y}{tibble column containing estimated vertical translations}

\item{theta}{tibble column containing estimated rotations}
}
\description{
The \code{feature_densityBased_all} function calculates the three density-based
features in one call. Calculate each feature individually using the
\code{feature_densityBased_thetaDiff}, \code{feature_densityBased_translationDiff}, and
\code{feature_densityBased_clusterSize} functions. The \code{densityBasedClusters} and
\code{estimatedRotation} functions are exported helpers.
}
\note{
The eps and minPts arguments are used differently depending on the
method specified. The eps argument is passed to the eps parameter in the
\code{dbscan::dbscan()} function if method == "dbscan" and to the eps_cl
parameter in the \code{dbscan::extractDBSCAN()} function if method == "optics"
}
\examples{
data("K013sA1","K013sA2")

compData <- comparison_cellBased(reference = K013sA1,
                                 target = K013sA2,
                                 thetas = c(-3,0,3))

# calculate all density-based features in one call
feature_densityBased_all(compData,eps = 5,minPts = 5)

# verify that we can calculate the same features using the individual
#   feature_densityBased_* functions
compData \%>\%
  dplyr::group_by(direction) \%>\%
  dplyr::filter(theta == estimatedRotation(x = x,y = y,theta = theta)) \%>\%
  dplyr::mutate(clust = densityBasedClusters(x = x,y = y,eps = 5,minPts = 5)) \%>\%
  dplyr::ungroup() \%>\%
  dplyr::summarise(thetaDiff = feature_densityBased_thetaDiff(estimatedThetas = theta,direction = direction),
                   translationDiff = feature_densityBased_translationDiff(x = x,y = y,cluster = clust,direction = direction),
                   clusterSize = feature_densityBased_clusterSize(cluster = clust,direction = direction))

}
\seealso{
\code{dbscan::dbscan()}, \code{dbscan::hdbscan()}, \code{dbscan::optics()} and
\code{dbscan::extractDBSCAN()}
}
